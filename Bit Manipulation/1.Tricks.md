## Swapping Two Numbers Without a Third Variable
Swapping two numbers can be efficiently done using the XOR operator, without the need for a temporary variable.

Example:
Given two numbers A = 5 and B = 6, swap them using XOR.
Step 1: A = A ^ B; (A becomes 3)
Step 2: B = A ^ B; (B becomes 5)
Step 3: A = A ^ B; (A becomes 6)
The numbers are swapped: A = 6, B = 5.
```
A = A ^ B
B = A ^ B
A = A ^ B

//Time Complexity: O(1) Each XOR operation is constant time.
//Space Complexity: O(1) No extra space used
```     

##  Checking if the i-th Bit is Set
To check if the i-th bit of a number is set, either the left shift or the right shift operator can be used.

Example:
Given a number 13 (binary 1101) and i = 2, check if the 2nd bit is set.
Left Shift: (1 << 2) results in 100. Perform AND with 13: 1101 & 0100 = 0100 (non-zero, hence the bit is set).
Right Shift: (13 >> 2) results in 0011. Perform AND with 1: 0011 & 0001 = 0001 (non-zero, hence the bit is set).

```
boolean isBitSet(int n, int i) {
    return (n & (1 << i)) != 0;
}
//Time Complexity: O(1) Each operation is constant time.
//Space Complexity: O(1) No extra space used.
```

## Setting the i-th Bit
To set the i-th bit of a number to 1, the bitwise OR operator can be used.

Example:
Given a number 9 (binary 1001) and i = 2, set the 2nd bit.
Step: (9 | (1 << 2)) results in 1101, which is 13.

```
int setBit(int n, int i) {
    return n | (1 << i);
}
//Time Complexity: O(1) Each operation is constant time.
//Space Complexity: O(1) No extra space used.
```

## Clearing the i-th Bit
To clear the i-th bit of a number, the bitwise AND operator can be used with the complement of the bit mask.

Example:
Given a number 13 (binary 1101) and i = 2, clear the 2nd bit.
Step: (13 & ~(1 << 2)) results in 1001, which is 9.

```
int clearBit(int n, int i) {
    return n & ~(1 << i);
}
//Time Complexity: O(1) Each operation is constant time.
//Space Complexity: O(1) No extra space used.
```

## Toggling the i-th Bit
Given a number 13 (binary 1101) and i = 1, toggle the 1st bit.

Example:
Given a number 13 (binary 1101) and i = 1, toggle the 1st bit.
Step:(13 ^ (1 << 1)) results in 1111, which is 15.

```
int toggleBit(int n, int i) {
    return n ^ (1 << i);
}
//Time Complexity: O(1) Each operation is constant time.
//Space Complexity: O(1) No extra space used.
```

## Checking if a Number is a Power of 2
To check if a number is a power of 2, the bitwise AND operator with n-1 can be used. If the result is 0, the number is a power of 2.

Example:
Given a number 16, check if it is a power of 2.
Step:(16 & (16 - 1)) results in 0, hence 16 is a power of 2.

```
boolean isPowerOfTwo(int n) {
    return (n > 0) && ((n & (n - 1)) == 0);
}
//Time Complexity: O(1) Each operation is constant time.
//Space Complexity: O(1) No extra space used.
```

## Counting the Number of Set Bits
Using a Loop and Bitwise AND
To count the number of set bits (1s) in a binary representation of a number, a loop can be used along with the bitwise AND operator.

Example:
Given a number 13 (binary 1101), count the set bits.
Step: (13 & 1) results in 1 (increment count)
Right shift 13 to get 110, (6 & 1) results in 0
Right shift 6 to get 11, (3 & 1) results in 1 (increment count)
Right shift 3 to get 1, (1 & 1) results in 1 (increment count)
The number 13 has 3 set bits.

```
int countSetBits(int n) {
    int count = 0;
    while (n > 0) {
        count += (n & 1);
        n >>= 1;
    }
    return count;
}
//Time Complexity: O(logN) Each bit is checked once.
//Space Complexity: O(1) No extra space used.
```

Optimized Approach Using n & (n-1)
An optimized approach to count set bits involves repeatedly turning off the rightmost set bit using n & (n-1).

Example:
Given a number 13 (binary 1101), keep on turning the rightmost set bit.
Keep on unsetting the last set bit in the number until the number has no set bits left.
The number of times the last bit is unset, will determine the number of set bits.
The number 13 has 3 set bits.

```
int countSetBits(int n) {
        int count = 0;
        while (n) {
            n &= (n - 1);
            count++;
        }
        return count;
    }
//Time Complexity: O(K) Where K is the number of set bits.
//Space Complexity: O(1) No extra space used.    
```