## Swapping Two Numbers Without a Third Variable
You can swap two integers without a temporary variable using XOR. XOR has the property that x ^ x = 0 and x ^ 0 = x, and it's reversible.

Demonstration (A = 5, B = 6):

- Binary: A = 5 -> 0101, B = 6 -> 0110
- Step 1: A = A ^ B -> A = 0101 ^ 0110 = 0011 (3)
- Step 2: B = A ^ B -> B = 0011 ^ 0110 = 0101 (5)
- Step 3: A = A ^ B -> A = 0011 ^ 0101 = 0110 (6)

After the three XORs, A = 6 and B = 5 (swapped).

Java example:
```
int A = 5, B = 6;
A = A ^ B; // A = 3 (0011)
B = A ^ B; // B = 5 (0101)
A = A ^ B; // A = 6 (0110)
// Now A=6, B=5
// TC: O(1)
// SC: O(1)
```

Notes:
- Works only when A and B are distinct memory locations; avoid using when A and B alias the same variable.
- For readability and safety (avoiding overflow/aliasing concerns), using a temporary variable is often preferred in production code.

## Checking if the i-th Bit is Set
To check whether the i-th bit (0-indexed from LSB) is set, you can use either a mask with left shift or shift the number to the right.

Example: n = 13 (1101), i = 2

- Left-shift mask: (1 << i) = 0100. n & mask = 1101 & 0100 = 0100 (non-zero) → bit is set.
- Right-shift: n >> i = 1101 >> 2 = 0011. (n >> i) & 1 = 0011 & 0001 = 0001 → bit is set.

Java example (mask approach):
```
boolean isBitSet(int n, int i) {
    return (n & (1 << i)) != 0;
}
// TC: O(1)
// SC: O(1)
```

Tip: Use mask approach when you want to test a specific index; use right-shift when scanning bits from LSB to MSB.

## Setting the i-th Bit
Set the i-th bit to 1 by OR-ing with a mask that has the i-th bit set.

Example: n = 9 (1001), i = 2

- Mask: (1 << 2) = 0100. n | mask = 1001 | 0100 = 1101 (13).

Java:
```
int setBit(int n, int i) {
    return n | (1 << i);
}
// TC: O(1)
// SC: O(1)
```

## Clearing the i-th Bit
Clear (set to 0) the i-th bit by AND-ing with the complement of the mask.

Example: n = 13 (1101), i = 2

- Mask: ~(1 << 2) = ~0100 = 1011 (infinite 1s for signed but effect on the target bits keeps 0 at position i).
- n & ~mask = 1101 & 1011 = 1001 (9).

Java:
```
int clearBit(int n, int i) {
    return n & ~(1 << i);
}
// TC: O(1)
// SC: O(1)
```

## Toggling the i-th Bit
Toggle flips the i-th bit: XOR with mask (1 << i).

Example: n = 13 (1101), i = 1

- Mask: 0010. n ^ mask = 1101 ^ 0010 = 1111 (15). If bit was 1 it becomes 0, if 0 becomes 1.

Java:
```
int toggleBit(int n, int i) {
    return n ^ (1 << i);
}
// TC: O(1)
// SC: O(1)
```

## Removing the Last Set Bit (rightmost 1)
The expression n & (n - 1) clears the lowest set bit in n. This works because subtracting 1 flips all bits from the rightmost 1 (inclusive) and leaves higher bits unchanged; AND-ing clears that rightmost 1.

Example: n = 13 (1101)

- n - 1 = 12 (1100)
- n & (n - 1) = 1101 & 1100 = 1100 (12) — the rightmost 1 was removed.

Java:
```
int removeLastSetBit(int n) {
    return n & (n - 1);
}
// TC: O(1)
// SC: O(1)
```

Use case: useful when iterating over set bits or implementing the optimized popcount below.

## Checking if a Number is a Power of Two
A positive integer n is a power of two iff it has exactly one bit set. So (n & (n - 1)) == 0 and n > 0.

Example: n = 16 (10000)

- n - 1 = 15 (01111)
- n & (n - 1) = 10000 & 01111 = 00000 → zero, so 16 is a power of two.

Java:
```
boolean isPowerOfTwo(int n) {
    return (n > 0) && ((n & (n - 1)) == 0);
}
// TC: O(1)
// SC: O(1)
```

## Counting the Number of Set Bits (Popcount)
1) Simple loop (check each bit):

Algorithm: Check LSB using n & 1, then right-shift n until it becomes 0.

Example: n = 13 (1101)

- 1101 & 1 = 1 → count = 1; n >>= 1 → 0110
- 0110 & 1 = 0 → count = 1; n >>= 1 → 0011
- 0011 & 1 = 1 → count = 2; n >>= 1 → 0001
- 0001 & 1 = 1 → count = 3; n >>= 1 → 0000 → stop

Java:
```
int countSetBits(int n) {
    int count = 0;
    while (n > 0) {
        count += (n & 1);
        n >>= 1;
    }
    return count;
}
// TC: O(log n) where log n is the number of bits
// SC: O(1)
```

2) Optimized: repeatedly remove lowest set bit (n &= n - 1)

Algorithm: Each iteration removes one set bit. Complexity depends on number of set bits (k).

Example: n = 13 (1101)

- Iter 1: n = 1101 -> n & (n-1) = 1100 (count=1)
- Iter 2: n = 1100 -> n & (n-1) = 1000 (count=2)
- Iter 3: n = 1000 -> n & (n-1) = 0000 (count=3) -> stop

Java:
```
int countSetBitsOptimized(int n) {
    int count = 0;
    while (n != 0) {
        n &= (n - 1);
        count++;
    }
    return count;
}
// TC: O(k) where k is the number of set bits
// SC: O(1)
```

When to use which:
- If you expect very sparse set bits (small k), the optimized method is faster.
- For dense numbers (close to half or more bits set), both approaches are comparable; modern CPUs also offer builtins (e.g., Integer.bitCount in Java) which are typically fastest.

---
If you'd like, I can:
- Add small runnable Java snippets (complete class + main) for each trick so you can compile and run them.
- Add equivalent C++/Python snippets.
Which would you prefer? 