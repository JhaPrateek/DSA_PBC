### Given an array nums where each integer in nums appears thrice except one. Find out the number that has appeared only once.

Examples:

Input : nums = [2, 2, 2, 3]
Output : 3
Explanation : The integers 3 has appeared only once.

Input : nums = [1, 0, 3, 0, 1, 1, 3, 3, 10, 0]
Output : 10
Explanation : The integers 10 has appeared only once.

```java
import java.util.HashMap;

class Solution {
    /* Function to get the single 
    number in the given array */
    public int singleNumber(int[] nums) {
        
        /* Map to store the elements 
        and their frequencies */
        HashMap<Integer, Integer> mpp = new HashMap<>();
        
        // Iterate on the array
        for (int i = 0; i < nums.length; i++) {
            mpp.put(nums[i], mpp.getOrDefault(nums[i], 0) + 1); // Update the map
        }
        
        // Iterate on the map
        for (HashMap.Entry<Integer, Integer> it : mpp.entrySet()) {
            // If frequency is 1
            if (it.getValue() == 1) {
                // Return the element
                return it.getKey();
            }
        }
        
        /* Return -1, if there is no 
        number having frequency 1 */
        return -1;
    }

    public static void main(String[] args) {
        int[] nums = {2, 2, 2, 3};
        
        /* Creating an instance of 
        Solution class */
        Solution sol = new Solution();
        
        /* Function call to get the single 
        number in the given array */
        int ans = sol.singleNumber(nums);
        
        System.out.println("The single number in given array is: " + ans);
    }
}
Time Complexity: O(N) (where N is the size of the array) –
Traversing the array to update the Hash Map - O(N).
Traversing on the map - O(N) (in worst case).
Space Complexity: O(N) – Using a hashmap data structure and in the worst-case (when all elements in the array are unique), it will store N key-value pairs.
```

```java
import java.util.*;

class Solution {
    /* Function to get the single 
    number in the given array */
    public int singleNumber(int[] nums) {
        // Variable to store size of array
        int n = nums.length;
        
        // Variable to store the ans
        int ans = 0;
        
        // Checking every bit position
        for (int bitIndex = 0; bitIndex < 32; bitIndex++) {
            
            /* Variable to count number of 
            set bits in bitIndex position */
            int count = 0;
            
            // Traversing all elements 
            for (int i = 0; i < n; i++) {
                
                /* Counting elements having set
                bits at bitIndex position */
                if ((nums[i] & (1 << bitIndex)) != 0) {
                    count++;
                }
            }
            
            // Updating bits in answer
            if (count % 3 != 0) {
                ans |= (1 << bitIndex);
            }
        }
        
        return ans;
    }

    public static void main(String[] args) {
        int[] nums = {2, 2, 2, 3};
        
        /* Creating an instance of 
        Solution class */
        Solution sol = new Solution();
        
        /* Function call to get the single 
        number in the given array */
        int ans = sol.singleNumber(nums);
        
        System.out.println("The single number in given array is: " + ans);
    }
}
Time Complexity: O(32*N) – For every 32-bit position, all the elements of the array are traversed.
Space Complexity: O(1) – Using a couple of variables i.e., constant space.
```

```java
import java.util.Arrays;

class Solution {
    /* Function to get the single 
    number in the given array */
    public int singleNumber(int[] nums) {
        // Variable to store size of array
        int n = nums.length;
        
        // Sorting the array
        Arrays.sort(nums);
        
        // Traversing the array
        for (int i = 1; i < nums.length; i += 3) {
            /* Checking the elements 
            in the bucket */
            if (nums[i] != nums[i - 1]) {
                // Return the single number
                return nums[i - 1];
            }
        }
        
        /* If not found till now, then 
        the last number will be single */
        return nums[n - 1];
    }

    public static void main(String[] args) {
        int[] nums = {2, 2, 2, 3};
        
        /* Creating an instance of 
        Solution class */
        Solution sol = new Solution();
        
        /* Function call to get the single 
        number in the given array */
        int ans = sol.singleNumber(nums);
        
        System.out.println("The single number in given array is: " + ans);
    }
}
Time Complexity: O(Nlog(N)) –
Sorting the array takes O(Nlog(N)) TC.
Traversing the array takes O(N/3) TC. Hence, O(Nlog(N)) + O(N/3) = O(Nlog(N)).
Space Complexity: O(1) Using a couple of variables i.e., constant space.
```

```java
import java.util.*;

class Solution {
    public int singleNumber(int[] nums) {
        // Two buckets
        int ones = 0, twos = 0;

        // Traverse the array 
        for (int i = 0; i < nums.length; i++) {
            // Add the number to Ones, if it is not in Twos
            ones = (ones ^ nums[i]) & ~twos;

            // Add the number to Twos, if it is already in Ones
            twos = (twos ^ nums[i]) & ~ones;
        }

        return ones;
    }
}

class Main {
    public static void main(String[] args) {
        int[] nums = {1, 0, 3, 0, 1, 1, 3, 3, 10, 0};

        // Creating an instance of Solution class
        Solution sol = new Solution();

        // Function call to find the number that appears only once
        int ans = sol.singleNumber(nums);

        System.out.println("The single number(II) is: " + ans);
    }
}
Time Complexity: O(N), where N is the number of elements in the array
Traversing the array once takes linear time.
Space Complexity: O(1), as only a couple of variables are used. 
```

Explanation for last approach
Intuition:
The intuition for this approach may not be straightforward and is not typically required in interviews.

The goal is to identify the number that appears only once in an array where all other numbers appear exactly three times. Several observations can help solve this problem.

Imagine using three buckets named Ones, Twos, and Threes to keep track of numbers that appear once, twice, and thrice respectively while iterating through the array. These observations can be made:

A number can be added to Ones if it is not already in Twos.
A number can be added to Twos if it is already in Ones.
A number can be added to Threes if it is already in Twos.

This leads to the idea of using three variables to represent the three buckets and applying bit manipulation to add or remove numbers from the respective buckets efficiently.

Understanding:
To add and remove numbers from the buckets, bit manipulation is employed. Among the three basic operations (&, |, ^), the XOR (^) operation is particularly useful as it facilitates both addition and removal.

While traversing the array, there are three possible scenarios:
When the number is not in Twos: If the number is not in Twos, it indicates that this is the first occurrence of the number, so it should be added to the Ones bucket. This can be expressed as:
Ones = (Ones ^ num) & ~Twos;

When the number is already in Ones: If the number is in Ones, it means it is being encountered for the second time. In this case, the number should be removed from Ones and added to the Twos bucket. This can be expressed as:
Twos = (Twos ^ num) & ~Ones;

When the number is already in Twos: If the number is in Twos, it indicates a third occurrence. In this case, the number should be removed from both Ones and Twos. However, As we are concerned about the number that appears only once, we need not to store the third bucket Threes.
Result:
After processing all numbers in the array, the first bucket (ones) contains the bits of the number that appears only once. This is because:
Bitwise XOR (^): This toggles the bits. It adds a number to the bucket if it’s not already there and removes it if it is. Numbers appearing an even number of times cancel themselves out, while the number appearing once remains.
Bitwise AND with complement (& ~): This clears a number from the first bucket (ones) when it’s added to the second bucket (twos) or when numbers appear three times.

At the end, the first bucket retains the number that appeared exactly once, and this value is returned.
Approach:

Initialize two variables to represent two buckets for tracking numbers that have appeared once and twice.
Traverse the array, updating the buckets using bitwise operations:
Add the current number to the first bucket if it is not already in the second bucket.
Add the current number to the second bucket if it is already in the first bucket.
Ensure that numbers appearing three times are removed from both buckets by leveraging the properties of bitwise operations.
After processing all numbers, the first bucket holds the number that appears only once. Return this value.