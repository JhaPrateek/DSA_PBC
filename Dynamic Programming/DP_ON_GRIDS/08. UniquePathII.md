## You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.
Return the number of possible unique paths that the robot can take to reach the bottom-right corner.
Example:
Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
Explanation: There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right

```java
Memoization
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;

        // If the starting cell or the ending cell has an obstacle, no path is possible
        if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) {
            return 0;
        }

        // DP table initialized with -1
        int dp[][] = new int[m][n];
        for (int row[] : dp) {
            Arrays.fill(row, -1);
        }

        return fun(m - 1, n - 1, obstacleGrid, dp);
    }

    public int fun(int i, int j, int[][] obstacleGrid, int[][] dp) {
        // If an obstacle is found, return 0 (no valid path)
        if (i < 0 || j < 0 || obstacleGrid[i][j] == 1) {
            return 0;
        }

        // Base Case: If we reach the starting point and it's not blocked
        if (i == 0 && j == 0) {
            return 1;
        }

        // If the result is already computed, return it
        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        // Calculate the number of ways by moving from top and left
        int top = fun(i - 1, j, obstacleGrid, dp);
        int left = fun(i, j - 1, obstacleGrid, dp);

        // Store the computed value in the DP table and return it
        return dp[i][j] = top + left;
    }
}
Time Complexity: O(N*M)
Reason: At max, there will be N*M calls of recursion.
Space Complexity: O((M-1)+(N-1)) + O(N*M)
Reason: We are using a recursion stack space:O((M-1)+(N-1)), here (M-1)+(N-1) is the path length and an external DP Array of size ‘N*M’.
```

```java
Tabulation
class Solution {
    public int uniquePathsWithObstacles(int[][] matrix) {

        int m = matrix.length;        // Total rows
        int n = matrix[0].length;     // Total columns

        int dp[][] = new int[m][n];   // DP table to store number of paths

        // If start (0,0) or end (m-1,n-1) is an obstacle,
        // then no valid path exists at all.
        if (matrix[0][0] == 1 || matrix[m-1][n-1] == 1) {
            return 0;
        }

        // Starting point (0,0)
        // There is EXACTLY 1 way to be at the start — by just being there.
        dp[0][0] = 1;

        // -----------------------------
        // FILL FIRST ROW
        // -----------------------------
        // For the first row, the only way to move is RIGHT.
        // So if a cell has no obstacle, it inherits the number of ways
        // from the cell directly LEFT of it.
        // If matrix[0][j] == 1 (obstacle), dp will naturally remain 0.
        for (int j = 1; j < n; j++) {
            if (matrix[0][j] == 0) {
                // You can only reach first row from the left.
                dp[0][j] = dp[0][j - 1];
            }
            // If matrix[0][j] == 1, dp remains 0 (not reachable)
        }

        // -----------------------------
        // FILL FIRST COLUMN
        // -----------------------------
        // For the first column, the only way to move is DOWN.
        // So if a cell has no obstacle, it inherits the number of ways
        // from the cell directly ABOVE it.
        for (int i = 1; i < m; i++) {
            if (matrix[i][0] == 0) {
                // You can only reach first column from above.
                dp[i][0] = dp[i - 1][0];
            }
            // If matrix[i][0] == 1, dp remains 0 (not reachable)
        }

        // -----------------------------
        // FILL REST OF THE GRID
        // -----------------------------
        // For every other cell, you can reach it either:
        // 1. From the TOP (i-1, j)
        // 2. From the LEFT (i, j-1)
        //
        // So total ways = ways from TOP + ways from LEFT
        //
        // But if there's an obstacle at matrix[i][j], then no path can pass
        // through this cell, so dp[i][j] = 0.
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {

                // If cell itself is blocked, no paths lead here.
                if (matrix[i][j] == 1) {
                    dp[i][j] = 0;
                } 
                else {
                    // Sum of ways from top and left
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }

        // The bottom-right cell contains the total number of unique paths
        return dp[m - 1][n - 1];
    }
}

```
