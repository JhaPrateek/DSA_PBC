## There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.
Example:
Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down

```java
Recursive
class Solution {
    public int uniquePaths(int m, int n) {
        // We start from the bottom-right corner (m-1, n-1) and try to reach (0,0)
        return fun(m - 1, n - 1);
    }

    public int fun(int i, int j) {
        // Base case: If we reach the starting point (0,0), there's only one way (staying there)
        if (i == 0 && j == 0) {
            return 1;
        }
        // If we go out of bounds (negative index), return 0 as it's not a valid path
        if (i < 0 || j < 0) {
            return 0;
        }
        
        // Recursive call: Move up (decrease row index)
        int top = fun(i - 1, j);
        // Recursive call: Move left (decrease column index)
        int left = fun(i, j - 1);
        
        // The total number of unique paths is the sum of ways from the top and left
        return top + left;
    }
}
Tc-O(2^m*n)
SC-O(path length)
```

```java
Memoization
class Solution {
    public int uniquePaths(int m, int n) {
        // Create a DP table initialized with -1 to indicate uncomputed values
        int dp[][] = new int[m][n];
        // Fill the DP array with -1 (to indicate values haven't been computed yet)
        for (int row[] : dp) {
            Arrays.fill(row, -1);
        }
        // Start recursion with memoization
        return fun(m - 1, n - 1, dp);
    }
    public int fun(int i, int j, int dp[][]) {
        // Base Case: If we reach the starting cell (0,0), there's one way to be there
        if (i == 0 && j == 0) {
            return 1;
        }
        // If we move out of the grid, return 0 (invalid path)
        if (i < 0 || j < 0) {
            return 0;
        }
        // Check if the result is already computed in dp table
        if (dp[i][j] != -1) {
            return dp[i][j]; // Return the precomputed result
        }
        // Compute number of ways by moving from top and left
        int top = fun(i - 1, j, dp);
        int left = fun(i, j - 1, dp);
        // Store the computed value in the DP table and return it
        return dp[i][j] = top + left;
    }
}
Time Complexity: O(M*N), where M is the number of row and N is the number of column in 2D array. At max, there will be M*N calls of recursion as the subproblems can go upto M*N.

Space Complexity:O((N-1)+(M-1)) + O(M*N), We are using a recursion stack space: O((N-1)+(M-1)), here (N-1)+(M-1) is the path length and an external DP Array of size ‘M*N’.
```

```java
Tabulation

Logic
-Create a DP array dp[m][n].
dp[i][j] will represent number of ways to reach cell (i, j).
-Base case:
First row → only 1 way (keep moving right).
First column → only 1 way (keep moving down).
-Transition:
dp[i][j] = dp[i-1][j] + dp[i][j-1];
Because:
You can come from top → dp[i-1][j]
Or from left → dp[i][j-1]
-Final answer = dp[m-1][n-1]

class Solution {
    public int uniquePaths(int m, int n) {
         int dp[][] = new int[m][n];

        // Step 1: Initialize first row and first column with 1
        for(int i = 0; i < m; i++){
            dp[i][0] = 1;  // Only downward movement
        }

        for(int j = 0; j < n; j++){
            dp[0][j] = 1;  // Only rightward movement
        }

        // Step 2: Fill rest of the table
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
}
TC-O(m*n)
SC-O(m*n)
```

```java

```
