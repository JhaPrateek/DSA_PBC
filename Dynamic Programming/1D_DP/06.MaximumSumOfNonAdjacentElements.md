### Given an integer array nums of size n. Return the maximum sum possible using the elements of nums such that no two elements taken are adjacent in nums.


Examples:
Input: nums = [1, 2, 4]

Output: 5

Explanation:

[1, 2, 4], the underlined elements are taken to get the maximum sum.

Input: nums = [2, 1, 4, 9]

Output: 11

Explanation:

[2, 1, 4, 9], the underlined elements are taken to get the maximum sum.

```java
Memoization
class Solution {

    public int nonAdjacent(int[] nums) {

        int n = nums.length;

        // DP array for memoization, initialize all with -1
        int arr[] = new int[n];
        Arrays.fill(arr, -1);

        // Start from last index (n-1)
        return fun(n - 1, nums, arr);
    }

    // Recursive function with memoization
    public int fun(int n, int nums[], int arr[]) {

        // Base case: when index reaches 0, we can only take that element
        if (n == 0) {
            return nums[0];
        }

        // Base case: if index goes negative, return 0
        // because out-of-bound means no value to pick
        if (n < 0) {
            return 0;
        }

        // If already computed, return stored result (Memoization)
        if (arr[n] != -1) {
            return arr[n];
        }

        // Option 1: Take current element
        // If we take nums[n], we must skip n-1 and go to n-2
        int take = nums[n] + fun(n - 2, nums, arr);

        // Option 2: Do NOT take current element
        // Move to the previous index
        int notTake = fun(n - 1, nums, arr);

        // Store and return the maximum of both choices
        return arr[n] = Math.max(take, notTake);
    }
}
```
**Time Complexity:** O(n) — each index is computed once due to memoization.

**Space Complexity:** O(n) — recursion stack plus the DP array (arr) of size n.

```java
Tabulation
class Solution {

    public int nonAdjacent(int[] nums) {

        int n = nums.length;

        // DP array for memoization, initialize all with -1
        int arr[] = new int[n];
        Arrays.fill(arr, -1);

        // Start from last index (n-1)
        return fun(n - 1, nums, arr);
    }

    // Recursive function with memoization
    public int fun(int n, int nums[], int arr[]) {

        // Base case: when index reaches 0, we can only take that element
        if (n == 0) {
            return nums[0];
        }

        // Base case: if index goes negative, return 0
        // because out-of-bound means no value to pick
        if (n < 0) {
            return 0;
        }

        // If already computed, return stored result (Memoization)
        if (arr[n] != -1) {
            return arr[n];
        }

        // Option 1: Take current element
        // If we take nums[n], we must skip n-1 and go to n-2
        int take = nums[n] + fun(n - 2, nums, arr);

        // Option 2: Do NOT take current element
        // Move to the previous index
        int notTake = fun(n - 1, nums, arr);

        // Store and return the maximum of both choices
        return arr[n] = Math.max(take, notTake);
    }
}
```
**Time Complexity:** O(n) — single pass to fill DP.

**Space Complexity:** O(n) — DP array of size n used in tabulation.

```java
Space Optimzation
import java.util.*;

class Solution {
    /* Function to calculate the maximum
    sum of nonAdjacent elements*/
    public int nonAdjacent(int[] nums) {
        int n = nums.length;
        int prev = nums[0];
        int prev2 = 0;

        for (int i = 1; i < n; i++) {
            // Maximum sum if we pick current element
            int pick = nums[i];
            
            if (i > 1) {
                // Add the maximum sum two elements ago
                pick += prev2;
            }
            // Maximum sum if we don't pick current element
            int nonPick = 0 + prev;

            // Maximum at the current element
            int cur_i = Math.max(pick, nonPick);

            prev2 = prev;
            prev = cur_i;
        }
        // Return the maximum sum
        return prev;
    }
}

```
**Time Complexity:** O(n) — single loop over the array.

**Space Complexity:** O(1) — constant extra space (prev and prev2 only).